---
layout: post
title:  "6.00.2xå­¦ä¹ ç¬”è®°Week3 Par1"
date:   2015-11-09
author: "Huang Qiang"
tags: [python, mooc, 6.00.2x]
---

æ¦‚ç‡é—®é¢˜æœ€æ—©æ˜¯æœ‰èµŒåšå¼•èµ·çš„ã€‚

ä¸€ä¸ªé—®é¢˜ã€‚ğŸ²ğŸ² roll 24æ¬¡ï¼ŒèµŒä»–ä»¬å¿…æœ‰ä¸€æ¬¡ï¼ˆ6ï¼Œ6ï¼‰æ˜¯ä¸æ˜¯åˆ’ç®—ã€‚

æˆ‘ä»¬çŸ¥é“ï¼Œrollä¸€æ¬¡ï¼Œä¸¤ä¸ªéƒ½æ˜¯6çš„æ¦‚ç‡æ˜¯(1/6)<sup>2</sup>, æ—¢(1/36)ã€‚é‚£ä¹ˆä¸æ˜¯ä¸¤ä¸ª6çš„æ¦‚ç‡å°±æ˜¯(35/36)ã€‚å¦‚æœæ˜¯roll24æ¬¡ï¼Œé‚£ä¹ˆä¸æ˜¯ä¸¤ä¸ª6çš„æ¦‚ç‡å°±æ˜¯(35/36)<sup>24</sup>ï¼Œæ—¢0.5085961238690966ã€‚ç”¨codeæ¥è¡¨ç¤ºæ—¢ï¼š

```python
import random

def rollDie():
    """returns a random int between 1 and 6"""
    return random.choice([1,2,3,4,5,6])

def checkPascal(numTrials, roll):
    yes = 0.0
    for i in range(numTrials):
        for j in range(24):
            d1 = roll()
            d2 = roll()
            if d1 == 6 and d2 == 6:
                yes += 1
                break
    print 'Probability of losing =', 1.0 - yes/numTrials

##checkPascal(10000, rollDie)
```
å¦‚æœæˆ‘ä»¬å¯¹ğŸ²ä½œå¼Š

```python
def rollLoadedDie():
    # å› ä¸ºå¦‚æœä¸ä½œå¼Šï¼Œæ¡ä»¶åº”è¯¥æ˜¯random.random() < 1.0/6.0
    # å› ä¸ºæœ‰1/6æœºç‡ğŸ²æ˜¯6ã€‚åˆ†æ¯å˜å°ï¼Œä¹Ÿå°±æ˜¯ç»“æœå˜å¤§ï¼Œæ—¢æ˜¯6çš„æ¦‚ç‡å˜å¤§ã€‚
    if random.random() < 1.0/5.5:
        return 6
    else:
        return random.choice([1,2,3,4,5])

##checkPascal(10000, rollLoadedDie)
```
ç»“æœå˜æˆäº†0.4428ï¼Œè¾“çš„æ¦‚ç‡ä¸‹é™ï¼Œèµ¢çš„ä¸Šå‡ã€‚

ä¸Šè¿°ä¾‹å­å¯ä»¥è¯´æ˜ï¼šsimulation is a wonderful tool for exploring what if questionsã€‚

è’™ç‰¹å¡ç½—æ–¹æ³•ï¼ˆè‹±è¯­ï¼šMonte Carlo methodï¼‰ï¼Œä¹Ÿç§°ç»Ÿè®¡æ¨¡æ‹Ÿæ–¹æ³•ï¼Œæ˜¯äºŒåä¸–çºªå››åå¹´ä»£ä¸­æœŸç”±äºç§‘å­¦æŠ€æœ¯çš„å‘å±•å’Œç”µå­è®¡ç®—æœºçš„å‘æ˜ï¼Œè€Œè¢«æå‡ºçš„ä¸€ç§ä»¥æ¦‚ç‡ç»Ÿè®¡ç†è®ºä¸ºæŒ‡å¯¼çš„ä¸€ç±»éå¸¸é‡è¦çš„æ•°å€¼è®¡ç®—æ–¹æ³•ã€‚æ˜¯æŒ‡ä½¿ç”¨éšæœºæ•°ï¼ˆæˆ–æ›´å¸¸è§çš„ä¼ªéšæœºæ•°ï¼‰æ¥è§£å†³å¾ˆå¤šè®¡ç®—é—®é¢˜çš„æ–¹æ³•ã€‚

20ä¸–çºª40å¹´ä»£ï¼Œåœ¨å†¯Â·è¯ºä¼Šæ›¼ï¼Œæ–¯å¡”å°¼æ–¯æ‹‰å¤«Â·ä¹Œæ‹‰å§†å’Œå°¼å¤æ‹‰æ–¯Â·æ¢…ç‰¹ç½—æ³¢åˆ©æ–¯åœ¨æ´›æ–¯é˜¿æ‹‰è«æ–¯å›½å®¶å®éªŒå®¤ä¸ºæ ¸æ­¦å™¨è®¡åˆ’å·¥ä½œæ—¶ï¼Œå‘æ˜äº†è’™ç‰¹å¡ç½—æ–¹æ³•ã€‚å› ä¸ºUlamçš„å”å”ç»å¸¸åœ¨è’™ç‰¹å¡ç½—èµŒåœºè¾“é’±å¾—åï¼Œè€Œè’™ç‰¹å¡ç½—æ–¹æ³•æ­£æ˜¯ä»¥æ¦‚ç‡ä¸ºåŸºç¡€çš„æ–¹æ³•ã€‚

ä¸å®ƒå¯¹åº”çš„æ˜¯ç¡®å®šæ€§ç®—æ³•ã€‚

è’™ç‰¹å¡ç½—æ–¹æ³•åœ¨é‡‘èå·¥ç¨‹å­¦ï¼Œå®è§‚ç»æµå­¦ï¼Œç”Ÿç‰©åŒ»å­¦ï¼Œè®¡ç®—ç‰©ç†å­¦ï¼ˆå¦‚ç²’å­è¾“è¿è®¡ç®—ã€é‡å­çƒ­åŠ›å­¦è®¡ç®—ã€ç©ºæ°”åŠ¨åŠ›å­¦è®¡ç®—ï¼‰ç­‰é¢†åŸŸåº”ç”¨å¹¿æ³›ã€‚

è¿™ä¸ªæƒ³æ³•çš„å¾—å‡ºæ˜¯Ulamè¯•å›¾è®¡ç®—solitaireï¼ˆçº¸ç‰Œï¼‰èµ¢çš„æ¦‚ç‡æ—¶ã€‚å‘ç°è®¡ç®—èµ·æ¥å®åœ¨å¤ªå¤æ‚ã€‚èƒ½ä¸èƒ½ç”¨ç»Ÿè®¡çš„æ–¹æ³•æ¥ç®—å‡ºå®ƒçš„æ¦‚ç‡æ¥ã€‚

A Monte Carlo simulation is a method of estimating the value of an unknown quantity using the principles of inferential statistics.

å…³é”®è¯æ˜¯estimationï¼Œå› ä¸ºMonte Carlo simulationå¾—å‡ºçš„ä¸æ˜¯å‡†ç¡®ç»“æœã€‚ç»“æœæ˜¯inferentialï¼Œæ˜¯æ¨æ–­å‡ºçš„ã€‚

å®ƒçš„ä¾æ®æ˜¯ï¼ša random sample tends to exhibit the same properties as a population from which it is drawn.

ä¾‹å­ï¼š

1. å¦‚æœä½ ç¡¬å¸ä¸¢100æ¬¡ï¼Œ100æ¬¡éƒ½æ˜¯headï¼Œé‚£ä½ å¯ä»¥æ¨æ–­å‡ºï¼Œç¡¬å¸ä¸¤è¾¹éƒ½æ˜¯headã€‚
2. ä½†å¦‚æœheadæ˜¯52æ¬¡ï¼Œtailæ˜¯48æ¬¡ã€‚é‚£ä¹ˆå†ä¸¢100æ¬¡çš„ç»“æœå°±ä¸ä¸€å®šæ˜¯å¤´å¤šå°¾å°‘äº†ã€‚

```python
def flip(numFlips):
    heads = 0
    for i in range(numFlips):
        if random.random() < 0.5:
            heads += 1
    return heads/float(numFlips)

for i in range(5): #number of trials
    print flip(10)
```
å¦‚æœæ¯è½®æ‰”10æ¬¡ï¼Œè®¡ç®—å‡ºçš„ç»“æœåå·®å¾ˆå¤§ã€‚æˆ‘ä»¬æ¨æ–­ä¸å‡ºcoinæ­£åçš„æ¦‚ç‡ã€‚
æ¯è½®æ‰”1,000,000æ¬¡ï¼Œè®¡ç®—ç»“æœå°±å¾ˆæ¥è¿‘ã€‚æˆ‘ä»¬å°±æ­¤å¯ä»¥åŸºæœ¬æ¨æ–­å‡ºç¡¬å¸æ­£åæ¦‚ç‡æ˜¯å„50ï¼…ã€‚é‚£ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ

### Buffon-Laplace method of estimating pi by dropping needles

å¸ƒå†¯æŠ•é’ˆæ±‚Ï€ã€‚

åœ¨ä¸€ä¸ªå˜é•¿ä¸º2çš„æ­£æ–¹å½¢ä¸­ç”»ä¸€ä¸ªå†…åˆ‡åœ†ã€‚
å¦‚æœå®Œå…¨éšæœºçš„æƒ…å†µä¸‹æŠ•é’ˆã€‚

åœ†å†…é’ˆçš„æ•°ç›®ï¼šæ‰€æœ‰é’ˆçš„æ•°ç›® ï¼ åœ†çš„é¢ç§¯ï¼šæ­£æ–¹å½¢çš„é¢ç§¯

å› è€Œï¼š

åœ†çš„é¢ç§¯ ï¼ ï¼ˆæ­£æ–¹å½¢é¢ç§¯ï¼Šåœ†å†…é’ˆæ•°é‡ï¼‰ï¼ æ‰€æœ‰é’ˆçš„æ•°é‡ã€‚

Ï€ï¼Šr<sup>2</sup> = 4ï¼Šï¼ˆåœ†å†…é’ˆæ•°é‡ï¼æ‰€æœ‰é’ˆæ•°é‡ï¼‰ï¼ˆå†…åˆ‡åœ†rï¼1ï¼‰æ‰€ä»¥ï¼š

Ï€ ï¼ 4ï¼Šï¼ˆåœ†å†…é’ˆæ•°é‡ï¼æ‰€æœ‰é’ˆæ•°é‡ï¼‰

å› ä¸ºäººä¸å¯èƒ½å®Œå…¨éšæœºçš„ä¸¢é’ˆï¼Œä½†æ˜¯è®¡ç®—æœºå¯ä»¥ã€‚
ç”¨ä»£ç è¡¨ç¤ºï¼š

```python
def throwNeedles(numNeedles):
    inCircle = 0
    for Needles in xrange(1, numNeedles + 1, 1):
        x = random.random()
        y = random.random()
        if (x*x + y*y)**0.5 <= 1.0:
            inCircle += 1
    return 4*(inCircle/float(numNeedles))
# x,yè¡¨ç¤ºé’ˆçš„åæ ‡ï¼Œéƒ½ < 1ã€‚å¦‚æœä»–ä»¬è·åŸç‚¹çš„è·ç¦» <= 1ã€‚è¯´æ˜åœ¨åœ†å†…ã€‚
```
```python
def getEst(numNeedles, numTrials):
    estimates = []
    for t in range(numTrials):
        piGuess = throwNeedles(numNeedles)
        estimates.append(piGuess)
    sDev = stdDev(estimates)
    curEst = sum(estimates)/len(estimates)
    print 'Est. = ' + str(curEst) +\
          ', Std. dev. = ' + str(round(sDev, 6))\
          + ', Needles = ' + str(numNeedles)
    return (curEst, sDev)
```
simulationä¸€å®šè¦åšå¤šæ¬¡ï¼Œå¹¶ä¸”çœ‹ä»–ä»¬æ ‡å‡†æ–¹å·®ï¼Œè¿™æ ·ä¸ä»…ä»…æ˜¯å¾—åˆ°ç­”æ¡ˆï¼Œè¿˜è¦çŸ¥é“ç­”æ¡ˆæœ‰å¤šå‡†ç¡®ã€‚`getEst()` è¿™é‡Œç»™å‡ºäº†å¤šæ¬¡æµ‹è¯•çš„ç®—æœ¯å¹³å‡`curEst`å’Œæ ‡å‡†æ–¹å·®`sDev`ã€‚

```python
def estPi(precision, numTrials):
    numNeedles = 1000
    sDev = precision
    while sDev >= precision/2.0:
        curEst, sDev = getEst(numNeedles, numTrials)
        numNeedles *= 2
    return curEst
    
random.seed(0)
estPi(0.005, 100)
```
æ‰€ä»¥æˆ‘ä»¬ä¸€ç›´ç®—åˆ°æ ‡å‡†æ–¹å·®å°äº0.005çš„ä¸€åŠä¸ºæ­¢ã€‚å¦‚æœæ ‡å‡†æ–¹å·®å¤§äºå®ƒï¼Œå°±æŠŠ`numNeedle`ç¿»å€å†ç®—ã€‚

```
Est. = 3.14844, Std. dev. = 0.047886, Needles = 1000
Est. = 3.13918, Std. dev. = 0.035495, Needles = 2000
Est. = 3.14108, Std. dev. = 0.02713, Needles = 4000
Est. = 3.141435, Std. dev. = 0.016805, Needles = 8000
Est. = 3.141355, Std. dev. = 0.0137, Needles = 16000
Est. = 3.14131375, Std. dev. = 0.008476, Needles = 32000
Est. = 3.141171875, Std. dev. = 0.007028, Needles = 64000
Est. = 3.1415896875, Std. dev. = 0.004035, Needles = 128000
Est. = 3.14174140625, Std. dev. = 0.003536, Needles = 256000
Est. = 3.14155671875, Std. dev. = 0.002101, Needles = 512000
```
è™½ç„¶è®¡ç®—ç»“æœ64000çš„Estæ¯”32000çš„Estçœ‹ä¸Šå»åå·®è¦å¤§ã€‚ä½†æ˜¯å¦‚æœæŠŠæ ‡å‡†æ–¹å·®ç®—è¿›æ¥ï¼Œå…¶å®64000çš„èŒƒå›´æ¯”32000çš„èŒƒå›´è¦å°ã€‚

It is not sufficient to produce a good answer. We have to have a valid reason to be confident that in fact, it really is a good answer.

ä½†æ˜¯good answerä¸èƒ½åªçœ‹æ ‡å‡†æ–¹å·®æ˜¯ä¸æ˜¯éšç€æµ‹è¯•åŸºæ•°å¢åŠ è€Œå‡å°ã€‚å› ä¸ºè¿™åªæ˜¯æ„å‘³ç€ï¼Œæˆ‘ä»¬ä»ä¸€ä¸ªé›†åˆä¸­å–çš„sampleè¶Šå¤šï¼Œæˆ‘ä»¬çš„åˆ°çš„ç»“æœè¶Šæ¥è¿‘ã€‚è¿™å¹¶ä¸ä»£è¡¨æ•°å€¼æ­£ç¡®ã€‚

è¦ç¡®ä¿ç»“æœæ­£ç¡®ï¼Œå¿…é¡»åšåˆ°ä»¥ä¸‹ä¸‰ç‚¹ï¼š

* Our conceptual model is correctã€‚ä»ä»£æ•°è§’åº¦å¯¹Ï€çš„ç®—æ³•æ­£ç¡®
* Our implementation is correctã€‚codeé‡Œé¢å¯èƒ½æœ‰bug
* We have enough samples to actually believe the resultã€‚è¿™ä¸ªæ˜¯æ ‡å‡†æ–¹å·®åšçš„äº‹æƒ…ã€‚

æœ€åï¼Œè¿˜è¦è¿›è¡Œå®é™…çš„æµ‹è¯•ï¼Œçœ‹çœ‹ç»“æœæ˜¯å¦ä¸simulationç›¸ç¬¦ã€‚

---