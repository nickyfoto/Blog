---
layout: post
title:  "6.00.2xå­¦ä¹ ç¬”è®°Week2 Part2"
date:   2015-11-06
author: "Huang Qiang"
tags: [python, mooc, 6.00.2x]
---

# Probability

ğŸ²æ‰5æ¬¡ï¼Œä¸å‡ºç°ä¸€ä¸ª1çš„å¯èƒ½æ€§æ˜¯ï¼š(5/6)<sup>5</sup>

è‡³å°‘å‡ºç°ä¸€æ¬¡1çš„å¯èƒ½æ€§å°±æ˜¯ï¼š1 - (5/6)<sup>5</sup>

100ä¸ªå­¦ç”Ÿåœ¨ä¸€ä¸ªæ•™å®¤ï¼Œå¤šå¤§å¯èƒ½æ€§è¿™100ä¸ªäººä¸­ä»Šå¤©æœ‰äººè¿‡ç”Ÿæ—¥?

ç­”ï¼š1 - (364/365)<sup>100<sup>

# Hashing

chr()æ ¹æ®æ•´æ•°è¿”å›å¯¹åº”çš„å­—ç¬¦ï¼Œä¹Ÿå°±æ˜¯è®²asciiè½¬æ¢ä¸ºå­—ç¬¦

unichr()å°†æ•´æ•°è¿”å›æˆunicodeå­—ç¬¦

ord()å°†å­—ç¬¦è½¬æ¢æˆasciiç 

ä»ä¸ºä»€ä¹ˆä¼šå‡ºç°hashè®²èµ·ã€‚

convert the key to an integer and then use that integer to index into a list, which can be done in constant time because values of any object can be easily converted to an integer.

å› ä¸ºå¦‚æœæŠŠæ‰€æœ‰çš„stringéƒ½è½¬æ¢æˆintegerä¼šå¾ˆå¤§ï¼Œæ‰€ä»¥é‡‡å–å–ä½™æ•°çš„åŠæ³•ã€‚ä½†æ˜¯è¿™æ ·ä¼šäº§ç”Ÿcollisonï¼Œè¿™ä¸ªcollisonæ˜¯å¯ä»¥æ¥å—çš„ã€‚

We have collisions because a hash function is a many-to-one mapping. The whole point was to take a very large space and map each element in that space into a much smaller space.

æŠŠtableå˜å¤§ï¼Œcollisonå°±ä¼šå°‘ï¼Œä»¥ç©ºé—´æ¢æ—¶é—´ã€‚

æ¥ä¸‹æ¥çœ‹ä¸€ä¸‹æœ‰å¤šå¤§çš„æœºç‡ä¼šäº§ç”Ÿcollisonã€‚

```python
import random


class intDict(object):
    """A dictionary with integer keys"""
    
    def __init__(self, numBuckets):
        """Create an empty dictionary"""
        self.buckets = []
        self.numBuckets = numBuckets
        for i in range(numBuckets):
            self.buckets.append([])
            
    def addEntry(self, dictKey, dictVal):
        """Assumes dictKey an int.  Adds an entry."""
        hashBucket = self.buckets[dictKey%self.numBuckets] #ç¡®å®šç¬¬å‡ ä¸ªbucket
        for i in range(len(hashBucket)): #éå†è¿™ä¸ªbucketä¸­çš„å…ƒç´ 
            if hashBucket[i][0] == dictKey: #å¦‚æœæœ‰ç›¸åŒçš„key
                hashBucket[i] = (dictKey, dictVal) #å°±æ›´æ–°
                return #è¿”å›ä¸ºç©ºè¡¨ç¤ºç»“æŸè¿™ä¸ªmethodå¹¶ä¸”ä¸æ‰§è¡Œä¸‹é¢çš„å‘½ä»¤
        hashBucket.append((dictKey, dictVal)) #å¦‚æœæ£€æŸ¥è¿‡åè¯¥bucketæ²¡æœ‰collisonï¼Œåˆ™æŠŠè¿™ä¸ªtupleæ·»åŠ åˆ°è¯¥bucketã€‚
        
    def getValue(self, dictKey):
        """Assumes dictKey an int.  Returns entry associated
           with the key dictKey"""
        hashBucket = self.buckets[dictKey%self.numBuckets]
        for e in hashBucket:
            if e[0] == dictKey:
                return e[1]
        return None
    
    def __str__(self):
        res = ''
        for b in self.buckets:
            for t in b:
                res = res + str(t[0]) + ':' + str(t[1]) + ','
        return '{' + res[:-1] + '}' #res[:-1] removes the last comma

#æœ‰29ä¸ªbucketsï¼Œè¦å¡20ä¸ªä¸œè¥¿è¿›å»ï¼Œkeyæ˜¯éšæœºç”Ÿæˆçš„ã€‚é€šè¿‡é™¤ä»¥29å¾—ä½™æ•°æ¥ç¡®å®šindexï¼Œä¹Ÿå°±æ˜¯å­˜å…¥è¿™29ä¸ªå½“ä¸­çš„ç¬¬å‡ ä¸ªbucketã€‚

D = intDict(29) 
for i in range(20):
    #choose a random int in range(10**5)
    key = random.choice(range(10**5))
    D.addEntry(key, i)

print '\n', 'The buckets are:'
for hashBucket in D.buckets: #violates abstraction barrier
    print '  ', hashBucket
```
è¿™æ—¶å†`print D`ï¼Œå°±ä¼šçœ‹åˆ°ç”Ÿæˆçš„ç»“æœã€‚

```python
>>> {59340:1,53628:10,94664:17,1981:19,85967:14,86490:8,52270:9,23272:13,6918:5,13704:6,85104:3,3266:11,64630:15,55438:18,61589:0,28358:2,72409:4,9567:7,76674:12,5653:16}
```
å½“æˆ‘ä»¬è¯´æœ‰nä¸ªbucketsã€‚è¦æ”¾Kä¸ªä¸œè¥¿è¿›å»ã€‚

æ”¾å…¥ç¬¬ä¸€ä¸ªä¸å¯èƒ½æœ‰collisonï¼Œå› ä¸ºæ‰€æœ‰çš„bucketséƒ½æ˜¯ç©ºçš„ã€‚ä¹Ÿå°±æ˜¯è¯´å†²çªçš„å¯èƒ½æ€§æ˜¯0ã€‚

å½“æ”¾ç¬¬ä¸€ä¸ªçš„æ—¶å€™ï¼Œä¸å†²çªçš„å¯èƒ½æ€§æ˜¯1

å½“æ”¾ç¬¬äºŒä¸ªçš„æ—¶å€™ï¼Œä¸å†²çªçš„å¯èƒ½æ€§æ˜¯(n-1)/n

å½“æ”¾ç¬¬ä¸‰ä¸ªçš„æ—¶å€™ï¼Œä¸å†²çªçš„å¯èƒ½æ€§æ˜¯(n-2)/n

å½“æ”¾ç¬¬Kä¸ªçš„æ—¶å€™ï¼Œä¸å†²çªçš„å¯èƒ½æ€§æ˜¯(n-(K-1))/n

è¿™æ—¶å€™ï¼Œå¦‚æœæˆ‘ä»¬è¦é—®ï¼Œå¦‚æœæŠŠKä¸ªä¸œè¥¿éƒ½æ”¾è¿›å»ï¼Œå‡ºç°å†²çªçš„å¯èƒ½æ€§æ˜¯å¤šå°‘ã€‚æ€è€ƒæ–¹æ³•ä¸å…ˆå‰è¯´çš„ç”Ÿæ—¥é—®é¢˜ä¸€æ ·ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåªæœ‰ä¸¤ç§å¯èƒ½ï¼Œä¸€ç§æ˜¯å†²çªäº†ï¼Œä¸€ç§æ˜¯æ²¡å†²çªï¼Œä¸¤è€…ä¹‹å’Œä»£è¡¨æ‰€æœ‰å¯èƒ½æ€§ï¼Œæ‰€ä»¥æ˜¯1ã€‚

ä¹Ÿå°±æ˜¯è¯´å‡ºç°å†²çªçš„å¯èƒ½æ€§ ï¼ 1 ï¼ ä¸Šè¿°ä¸è‚¯èƒ½çš„ä¹˜ç§¯ã€‚

ç”¨ä»£ç è¡¨ç¤ºï¼š

```python
def collision_prob(numBuckets, numInsertions):
    '''
    Given the number of buckets and the number of items to insert, 
    calculates the probability of a collision.
    '''
    prob = 1.0
    for i in range(1, numInsertions):
        prob = prob * ((numBuckets - i) / float(numBuckets))
    return 1 - prob
```
[Source Code](https://github.com/nickyfoto/Blog/blob/master/MIT.6.00.2x/code/files_finger_exercises_intDictTests.py)
